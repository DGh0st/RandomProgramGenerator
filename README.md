# Random Java program generator


**Graduate(G)/Undergrad(U):** U
**Email address:** dpate71@uic.edu
**First Name:** Deep
**Last Name:** Patel


**Graduate(G)/Undergrad(U):** U
**Email address:** kpate236@uic.edu
**First Name:** Krunal
**Last Name:** Patel


**Graduate(G)/Undergrad(U):** U
**Email address:** alwendl2@uic.edu
**First Name:** Anthony
**Last Name:** Wendling

## Program usage

The program can be ran using gradle and sbt:
```./gradlew run```
or
```sbt run```

This will generate the code into `GeneratedClasses/` folder.

Since our application makes use of Javassist to generate more object orientated code (inheritance, etc), the source code generated isn't completely native. We use javassist to create the structure of classes, methods, fields etc and to keep track of these methods/fields so it is easier to generate object oriented code.

## Configuration

Our random program generated has a lot of configurations which are used 

In config.txt, you can change the amount of how many of each type of varaiable is created.

In order to use the config.txt file to generate the source code, one of the following commands can be run:
```./gradlew run -PfilePath=config.txt```
or
```sbt "run config.txt"```

## Design Choices

The following are some design choices we made while working on this project.

**Why did we use Javassist?**

Since we were generating interfaces and abstract classes, we need a way to keep track of abstract methods so that we can later generate an implementation of this method. Javassist provides tracking of fields and methods of a class which is why we decided to use it. It also, provides other benefits such as checking if generated class can be compiled via the ```CtClass.toClass()```. We make use of this, in order to guareentee that the generated classes are syntactically correct.

The flaw with this approach is that Javassist can only generate byte code so we had to convert generated CtClass to source code. Since we are doing that, the generated source code isn't natively generated by our random program generator so compiling our source code may be slightly different than the bytecode generated by Javassist.

**Why are ClassFactory, StatementFactory, and ExpressionFactory factories and not builders?**

Well they should be named ClassBuilder, StatementBuilder, and ExpressionBuilder as they implement the builder pattern. We never got to refactoring/renaming them.

Originally we were planning on using abstract factory pattern to generate each, but we later decided to just use the builder pattern which also makes random selection of specific generation type easier.

**Where are Strings?**

We never got to generating String variables.
  
## Class

ClassFactory generates interfaces, abstract classes and concrete classes in that order so that there is always interfaces and abstract classes that can be extended or implemented by the concrete classes. The flaw of doing it this way is that the generated abstract classes will never extend concrete classes. Each of these are randomly generated between a range of value. Since the general structure of generation of each classes is the same, we decided to have a class named Class. This class is an abstract factory for generating different types of classes (interfaces, abstract classes and concrete classes). Each class is generated with the following steps:

```
1) Make CtClass
2) set modifiers
3) Initialize
```

The initialzie step could have been divide into more steps but we just let Interface, AbstractClass, and ConcreteClass (which extend Class) take care of it.

**Interfaces**

The generated interfaces have constant fields and abstract methods. The constant fields are only primitve types, mostly because no classes have been generated when interfaces are being generated. The abstract methods will have random number of arguments between a range.

**Abstract Classes**

The generated Abstract classes implements 0 or 1 interfaces (implements methods of these interfaces), non-constant fields, random amount of abstract methods between a range and random amount of concrete methods. There will always be atleast one abstract method.

**Concrete Classes**

These classes will essentially be the same as abstract classes except it will have 0 abstract methods, extend 0 or 1 other classes (abstract or concrete) and include a constructor. Concrete classes will sometimes also generate fields that are other concrete classes.

## Method
  
For method generation, we simply create a body for the method using StatementFactory (which should be StatementBuilder), create a `CtMethod` from the generated body, and then add it to the `CtClass`. We also generate a return statement at the end of the method if needed
  
## Statement
  
Statements can only exist inside a method so the invocation for a statement generation can only be made by methods or other statements.
We implemented assignment, for, if else, method invocation, type declartaion, and while statements to be generated for a random program.
All of the above statements inherit from parent Statement class and invocation rules are defined under Statement Factory class. 
Statement factory class takes care of random genration of various statements and specifications for each type of statements. 
  
## Expression
  
Expressions are neccesary for existence of some of the statements.
We implemented arithmetic, assignment, conditional and unary Expressions to be genrated.
All of the above expressions inherit from parent expression class and invocation rules are defined under Expression Factory class.
Expression Factory class takes care of the random genration of various expressions when possible or generate a specific expression for any specific requests.
